# Commands: Allow things to be processed asynchronously and produce messages

typename Command(a :: Type(Any, Any)) =
  [| NoCommand
   | CommandAppend : (Command(a), Command(a))
   | Spawn: (() {}~> a)
   | SpawnLinear: (() {}~@ a) |];


var empty = NoCommand;

sig append : forall a :: Type(Any, Any) .
  (Command(a), Command(a)) -> Command(a)
fun append(a1, a2) {
  switch ((a1, a2)) {
    case (NoCommand, a2) -> a2
    case (a1, NoCommand) -> a1
    case (a1, a2) -> CommandAppend(a1, a2)
  }
}


sig +$ : forall a :: Type(Any, Any) . (Command(a), Command(a)) -> Command(a)
op a1 +$ a2 { append(a1, a2) }


sig applySpawn: forall a :: Type(Any, Any) . (() {}~> a) {}~> a
fun applySpawn(f) { f() }

sig applySpawnLinear : forall a :: Type(Any, Any) . (() {}~@ a) {}~> a
fun applySpawnLinear(f) { f() }

sig processCommand :
  forall msg :: Type(Any, Any) . (Command(msg), AP(?msg.End)) ~> ()
fun processCommand(cmd, ap) {
  switch(cmd) {
    case NoCommand -> ()
    case CommandAppend(c1, c2) ->
      processCommand(c1, ap);
      processCommand(c2, ap)
    case Spawn(f) ->
      ignore(
        spawn {
          close(send(applySpawn(f), request(ap)))
        })
    case SpawnLinear(f) ->
      ignore(
        spawn {
          close(send(applySpawnLinear(f), request(ap)))
        })
  }
}
