### VDOM STUFF ###

# HTML Type

typename EventHandler(a :: Type(Any, Any)) =
  [| StringHandler: (String, (String) {}~> a)
   | UnitHandler: (String, () {}~> a)
   | TupleIntHandler: (String, ((Int,Int)) {}~> a)
   | TimeHandler: (Int, () {}~> a)
   | AnimationFrameHandler: ((a) {}~> a) |];

typename HTML(a :: Type(Any, Any)) =
  [| HTMLTextNode: (String)
   | HTMLTagNode:
      (tagName: String, attrs: [(String, String)],
       eventHandlers: [EventHandler(a)],
       children: [HTML(a)])
   |];

# Needed to ensure that virtual-dom is open
module VirtualDom {
  alien javascript "/lib/virtual-dom.js" {
    dummy : ();
  }
}

typename Sub(a :: Type(Any, Any)) =
  [| EmptySub
   | HandlerSub : (String, EventHandler(a))
   | Sub : (a) |];

# Loads the "vdom.js" file, exposes runDom and updateDom.
module VDom {
  alien javascript "/lib/vdom.js" {
    runDom : forall a :: Type(Any, Any) .
      (String, HTML(a), AP(?a.End), [Sub(a)]) ~%~> ();
    updateDom : forall a :: Type(Any, Any) . (HTML(a)) ~%~> ();
    updateSubscriptions : forall a :: Type(Any, Any) . (([Sub(a)],[Sub(a)])) ~%~> ();
    getUniqueID : forall a :: Type(Any, Any) . (EventHandler(a)) ~%~> (String);
    # diffSubs : forall a . (EventHandler(a)) ~%e~> (String);
  }
}
### SUBSCRIPTIONS ###


fun uniqueID(hdlr) {
  VDom.getUniqueID(hdlr)
}

fun getKeyDownCode(f) {
  var hdler = StringHandler("keydown", f);
  HandlerSub(uniqueID(hdler), hdler)
}

fun getKeyUpCode(f) {
  var hdler = StringHandler("keyup", f);
  HandlerSub(uniqueID(hdler), hdler)
}

fun getKeyPressCode(f) {
  var hdler = StringHandler("keypress", f);
  HandlerSub(uniqueID(hdler), hdler)
}

fun getMousePos(f) {
  var hdler = TupleIntHandler("mousemove", f);
  HandlerSub(uniqueID(hdler), hdler)
}

fun getEvery(interval, f) {
  var hdler = TimeHandler(interval, f);
  HandlerSub(uniqueID(hdler), hdler)
}

fun animationFrame(f) {
  var hdler = UnitHandler("animationFrame", f);
  HandlerSub(uniqueID(hdler), hdler)
}

######

sig textNode: forall a :: Type(Any, Any) . (String) ~> HTML(a)
fun textNode(str) {
  HTMLTextNode(str)
}

sig tag : forall a :: Type(Any, Any) .
  (String, [(String, String)], [EventHandler(a)], [HTML(a)]) -> HTML(a)
fun tag(nameOfTag, attrsOfTag, handlers, childrenOfTag) {
  HTMLTagNode((tagName=nameOfTag, attrs=attrsOfTag, eventHandlers=handlers, children=childrenOfTag))
}

fun attr(k, v) {
  (k, v)
}

# TODO: Put into a module
typename Command(a :: Type(Any, Any)) =
  [| NoCommand | Spawn: (() {}~> a) | SpawnLinear: (() {}~@ a) |];

sig applySpawn: forall a :: Type(Any, Any) . (() {}~> a) {}~> a
fun applySpawn(f) { f() }

sig applySpawnLinear : forall a :: Type(Any, Any) . (() {}~@ a) {}~> a
fun applySpawnLinear(f) { f() }

# TODO: Generalise to monoidal interface
sig processCommand :
  forall msg :: Type(Any, Any) . (Command(msg), AP(?msg.End)) ~> ()
fun processCommand(cmd, ap) {
  switch(cmd) {
    case NoCommand -> ()
    case Spawn(f) ->
      ignore(
        spawn {
          var _ = send(applySpawn(f), request(ap));
          ()
        })
    case SpawnLinear(f) ->
      ignore(
        spawn {
          var _ = send(applySpawnLinear(f), request(ap));
          ()
        })
  }
}

# Main event loop
sig evtLoop :
 forall msg :: Type(Any, Any),
        model :: Type(Any, Any),
        unrModel :: Type(Unl, Any) .
  (AP(?msg.End),
   model,
   (unrModel) ~%~> HTML(msg),
   (msg, model) ~%~> (model, Command(msg)),
   (unrModel) ~%~> [Sub(msg)],
   (model) ~%~> (model, unrModel),
   [Sub(msg)]) ~%~> ()
fun evtLoop(ap, model, view, updt, subscriptionsFn, extract, prevSubscriptions) {
  var (message, _) = receive(accept(ap));
  var (model, cmd) = updt(message, model);
  processCommand(cmd, ap);
  # Update DOM
  var (model, unrModel) = extract(model);
  # Get new subscriptions
  var newSubscriptions = subscriptionsFn(unrModel);
  # Update subscriptions on the DOM (FFI call)
  VDom.updateSubscriptions((prevSubscriptions, newSubscriptions));
  # Update DOM
  VDom.updateDom(view(unrModel));
  # Loop with new subscriptions
  evtLoop(ap, model, view, updt, subscriptionsFn, extract, newSubscriptions)
}

sig runLinear:
  forall
    msg::Type(Any, Any),
    model::Type(Any, Any),
    unrModel::Type(Unl, Any) .
  (String,
   model,
   (unrModel) ~%~> HTML(msg),
   (msg, model) ~%~> (model, Command(msg)),
   (unrModel) ~%~> [Sub(msg)],
   (model) ~%~> (model, unrModel)
   ) ~%~> ()
fun runLinear(placeholder, model, view, updt, subscriptions, extract) {
  var (model, unrModel) = extract(model);
  var evtHandler = spawnClient {
    var ap = new();
    VDom.runDom(placeholder, view(unrModel), ap, subscriptions(unrModel));
    evtLoop(ap, model, view, updt, subscriptions, extract, subscriptions(unrModel))
  };
  ()
}

# User-facing function (assuming an unrestricted model)
sig run:
  forall
    msg :: Type(Any, Any),
    model :: Type(Unl, Any) .
  (String,
    model,
    (model) ~%~> HTML(msg),
    (msg, model) ~%~> (model, Command(msg)),
    (model) ~%~> [Sub(msg)]) ~%~> ()
fun run(placeholder, model, view, updt, subscriptions) {
  runLinear(placeholder, model, view, updt, subscriptions, fun(x) { (x, x) })
}

sig runSimple :
  forall
    msg :: Type(Any, Any),
    model :: Type(Unl, Any) .
  (String,
    model,
    (model) ~%~> HTML(msg),
    (msg, model) ~%~> model) ~%~> ()
fun runSimple(placeholder, model, view, updt) {
  run(placeholder, model, view,
    fun(msg, model) { (updt(msg, model), NoCommand)},
    fun(_) { [] } )
}
