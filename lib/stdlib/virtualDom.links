### VDOM STUFF ###

# Doc Type

typename VirtualHandler(a) =
  [| StringHandler: (String, (String) {}~> a)
   | UnitHandler: (String, () {}~> a)
   | TupleIntHandler: (String, ((Int,Int)) {}~> a)
   | TimeHandler: (Int, () {}~> a)
   | AnimationFrameHandler: ((a) {}~> a) |];

typename Doc(a) =
  [| DocTextNode: (String)
   | DocTagNode:
      (tagName: String, attrs: [(String, String)], eventHandlers: [VirtualHandler(a)],
       children: [Doc(a)])
   |];

# Needed to ensure that virtual-dom is open
module VirtualDom {
  alien javascript "/lib/virtual-dom.js" {
    dummy : ();
  }
}

typename Sub(a) = [| EmptySub | HandlerSub : (String, VirtualHandler(a)) | Sub : (a) |];


# Loads the "vdom.js" file, exposes runDom and updateDom.
module VDom {
  alien javascript "/lib/vdom.js" {
    runDom : forall a . (String, Doc(a), Process({hear:a, wild}), [Sub(a)]) ~%e~> ();
    updateDom : forall a . (Doc(a)) ~%e~> ();
    updateSubscriptions : forall a . (([Sub(a)],[Sub(a)])) ~%e~> ();
    getUniqueID : forall a . (VirtualHandler(a)) ~%e~> (String);
    # diffSubs : forall a . (VirtualHandler(a)) ~%e~> (String);
  }
}
### SUBSCRIPTIONS ###


fun uniqueID(hdlr) {
  VDom.getUniqueID(hdlr)
}

fun getKeyDownCode(f) {
  var hdler = StringHandler("keydown", f);
  HandlerSub(uniqueID(hdler), hdler)
}

fun getKeyUpCode(f) {
  var hdler = StringHandler("keyup", f);
  HandlerSub(uniqueID(hdler), hdler)
}

fun getKeyPressCode(f) {
  var hdler = StringHandler("keypress", f);
  HandlerSub(uniqueID(hdler), hdler)
}

fun getMousePos(f) {
  var hdler = TupleIntHandler("mousemove", f);
  HandlerSub(uniqueID(hdler), hdler)
}

fun getEvery(interval, f) {
  var hdler = TimeHandler(interval, f);
  HandlerSub(uniqueID(hdler), hdler)
}

fun animationFrame(f) {
  var hdler = UnitHandler("animationFrame", f);
  HandlerSub(uniqueID(hdler), hdler)
}

######

fun textDoc(str) {
  DocTextNode(str)
}

# sig tag : (String, [(String, String)], [VirtualHandler(a)], [Doc(a)]) -> Doc(a)
fun tag(nameOfTag, attrsOfTag, handlers, childrenOfTag) {
  DocTagNode((tagName=nameOfTag, attrs=attrsOfTag, eventHandlers=handlers, children=childrenOfTag))
}

fun attr(k, v) {
  (k, v)
}

# TODO: Put into a module
typename Command(a) =
  [| NoCommand | Spawn: (() {}~> a) | SpawnLinear: (() {}~@ a) |];

# TODO: Generalise to monoidal interface
fun processCommand(cmd, pid) {

  switch(cmd) {
    case NoCommand -> ()
    case Spawn(f) ->
      ignore(
        spawn {
          var res = f();
          pid ! res
        })
    case SpawnLinear(f) ->
      ignore(
        spawn {
          var res = f();
          pid ! res
        })
  }
}

# Main event loop
fun evtLoop(updt, extract, render, model, prevSubscriptions, subscriptionsFn) {
  receive {
    case msg ->
      var (model, cmd) = updt(msg, model);
      processCommand(cmd, self());
      # Update DOM
      var (model, unrModel) = extract(model);
      # Get new subscriptions
      var newSubscriptions = subscriptionsFn(unrModel);
      # Update subscriptions on the DOM (FFI call)
      VDom.updateSubscriptions((prevSubscriptions, newSubscriptions));
      # Update DOM
      VDom.updateDom(render(unrModel));
      # Loop with new subscriptions
      evtLoop(updt, extract, render, model, newSubscriptions, subscriptionsFn)
  }
}

# TODO: Type signatures for these
fun runLinearVDom(placeholder, view, updt, extract, model, subscriptions) {
  var (model, unrModel) = extract(model);
  var evtHandler = spawnClient {
    evtLoop(updt, extract, view, model, subscriptions(unrModel), subscriptions)
  };
  var _ = spawnClient { VDom.runDom(placeholder, view(unrModel), evtHandler, subscriptions(model)) };
  evtHandler
}

# User-facing function (assuming an unrestricted model)
fun runVDom(placeholder, view, updt, model, subscriptions) {
  runLinearVDom(placeholder, view, updt, fun(x) { (x, x) },
    model, subscriptions)
}

