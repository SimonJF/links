Orderby clause (not a semantic test, just syntax)
for (x <- [1, 2, 3]) orderby (x) [x]
stdout : [1, 2, 3] : [Int]
exit : 0

XML literals in query blocks (1)
query { for (x <- [(<a>asdf</a>)]) [(b=2)] }
stdout : [(b = 2)] : [(b:Int)]
exit : 0

XML literals in query blocks (2)
query { for (x <- (<a>asdf</a>)) [(b=2)] }
stdout : [(b = 2)] : [(b:Int)]
exit : 0

XML literals in query blocks (3)
query { for (x <- (<a>asdf</a>)) [(b=2)] }
stdout : [(b = 2)] : [(b:Int)]
exit : 0

XML literals in query blocks (4)
query {var x = <a>asdf</a>; [(a=1)]}
stdout : [(a = 1)] : [(a:Int)]
exit : 0

XML literals in query blocks (5)
query {var x = <a href="foo.com">asdf</a>; [(a=1)]}
stdout : [(a = 1)] : [(a:Int)]
exit : 0

XML literals in query blocks (6)
query {var x = <a href="foo.com">{stringToXml("asdf")}</a>; [(a=1)]}
stdout : [(a = 1)] : [(a:Int)]
exit : 0

XML literals in query blocks (6)
query {var x = <a {[("href", "foo.com")]}>{stringToXml("asdf")}</a>; [(a=1)]}
stdout : [(a = 1)] : [(a:Int)]
exit : 0

Explicit query evaluator annotation (1)
query nested { for (x <- [1,2,3]) [(x = x, y = (for (y <- [4,5,6]) [y]))] }
stdout : [(x = 1, y = [4, 5, 6]), (x = 2, y = [4, 5, 6]), (x = 3, y = [4, 5, 6])] : [(x:Int,y:[Int])]
exit : 0

Explicit query evaluator annotation (2)
query plain { for (x <- [1,2,3]) [(x = x, y = (for (y <- [4,5,6]) [y]))] }
args : --config=tests/shredding/config.sample
stderr : @..*
exit : 1

Explicit query evaluator annotation (3)
query [4] plain { for (x <- [1, 2, 3, 4, 5, 6]) [(x = x)] }
args : --config=tests/shredding/config.sample
stdout : [(x = 1), (x = 2), (x = 3), (x = 4)] : [(x : Int)]
ignore : pending #756
exit : 0
