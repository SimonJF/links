var db = database "links";

var employees =
  table "employees" with (name: String, salary: Int, position_id: Int)
  using valid_time(valid_from, valid_to) from db;

var positions =
  table "positions" with (position_id: Int, position: String)
  where position_id readonly from db;

# SJF: We really should have sugar for this.
fun hire(name, salary, positionID, startDate, endDate) {
  vt_insert employees
    values
    (name, salary, position_id)
    [withValidity(
        (=name, =salary, position_id = positionID), startDate, endDate)]
}

fun fire(name) {
  delete current (x <-v- employees)
    where (x.name == name)
}

fun extendContract(name, date) {
  update nonsequenced (x <-v- employees)
    where (vtData(x).name == name && now() >= vtFrom(x) && now() < vtTo(x))
    set (valid from vtFrom(x) to date)
}

fun promote(name, salary, positionID) {
  update current (x <-v- employees)
    where (x.name == name)
    set (position_id = positionID, =salary)
}

fun lookupAt(pred, time) {
  query {
    for (x <-v- employees)
      where (pred(x) && time >= vtFrom(x) && time < vtTo(x))
      [vtData(x)]
  }
}

# fun currentLookupWithTime(pred) {
#     query nested {
#       var time = now();
#       for (x <-v- employees)
#         where (pred(x) && time >= vtFrom(x) && time < vtTo(x))
#         [x]
#   }
# }

fun currentLookup(pred) {
  lookupAt(pred, now())
}

fun insertPositions() {
  insert positions values [(position = "PhD student")];
  insert positions values [(position = "Postdoc")];
  insert positions values [(position = "Lecturer")];
  insert positions values [(position = "Reader")];
  insert positions values [(position = "Professor")]
}

fun getPositions() {
  query {
    for (x <-- positions) [(x.position, x.position_id)]
  }
}

fun test() {

  insertPositions();
  var positions = getPositions();

  fun positionID(positionName) {
    switch (lookup(positionName, positions)) {
      case Just(x) -> x
      case Nothing -> error("Invalid position!")
    }
  }

  var t1 = now();
  hire("Alice", 15000, positionID("PhD student"), now(), forever());
  hire("Bob", 40000, positionID("Lecturer"), now(), forever());
  var t2 = now();
  assertEq(lookupAt(fun(x) { true }, t1), []);
  assertEq(sortBy(fun(x) { x.name }, currentLookup(fun(x) { true })),
      [
        (name = "Alice", salary = 15000, position_id = positionID("PhD student")),
        (name = "Bob", salary = 40000, position_id = positionID("Lecturer"))
      ]);
  promote("Alice", 30000, positionID("Postdoc"));
  assertEq(lookupAt(fun(x) { true }, t1), []);
  assertEq(sortBy(fun(x) { x.name }, lookupAt(fun(x) { true }, t2)),
      [
        (name = "Alice", salary = 15000, position_id = positionID("PhD student")),
        (name = "Bob", salary = 40000, position_id = positionID("Lecturer"))
      ]); 
  assertEq(sortBy(fun(x) { x.name }, currentLookup(fun(x) { true })),
      [
        (name = "Alice", salary = 30000, position_id = positionID("Postdoc")),
        (name = "Bob", salary = 40000, position_id = positionID("Lecturer"))
      ]);
  fire("Bob");
  assertEq(sortBy(fun(x) { x.name }, currentLookup(fun(x) { true })),
      [
        (name = "Alice", salary = 30000, position_id = positionID("Postdoc"))
      ]);
  assertEq(sortBy(fun(x) { x.name }, lookupAt(fun(x) { true }, t2)),
      [
        (name = "Alice", salary = 15000, position_id = positionID("PhD student")),
        (name = "Bob", salary = 40000, position_id = positionID("Lecturer"))
      ]);
  var carol_end_date = parseDate("2030-01-01 00:00:00");
  var carol_end_date_2 = parseDate("2033-01-01 00:00:00");
  hire("Carol", 40000, positionID("Lecturer"), now(), carol_end_date);
  extendContract("Carol", carol_end_date_2);
  var res = currentLookupWithTime(fun(x) { vtData(x).name == "Carol" })
  assertEq(vtTo(hd(res)), carol_end_date_2);
  assertEq(sortBy(fun(x) { x.name }, lookupAt(fun(x) { true }, carol_end_date_2)),
      [
        (name = "Alice", salary = 30000, position_id = positionID("Postdoc"))
      ])
}

test()
