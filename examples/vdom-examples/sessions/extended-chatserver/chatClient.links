open ChatSessions;
open VirtualDom;

typename ChatMessage =
  [| ChatMsg: (Nickname, Message) | LogMsg: Message |];

# Model: Can be one of three states.
#  1. Not connected to a room
#  2. Connected as "ordinary" user
#  3. Connected as moderator
typename RoomInfo =
  (roomName: RoomName,
   nicknames: [Nickname],
   topic: Topic,
   messages: [ChatMessage],
   currentChatMessage: String);

sig mkRoomInfo : (RoomName, Topic, [Nickname]) -> RoomInfo
fun mkRoomInfo(name, topic, nicks) {
  (roomName=name, nicknames=nicks, topic=topic, messages=[], currentChatMessage="")
}

typename Error =
  [| ErrInvalidName
   | ErrNameInUse
   | ErrBadRoom
   | ErrKicked
   |];

typename SelectedRoom = [| NewRoom | SelectedRoom: String |];

typename NotConnectedModel =
  (nickname: String,
   rooms: [RoomName],
   selectedRoom: SelectedRoom,
   newRoomText: RoomName,
   error: Maybe(Error));

fun mkNCModel(rooms, error) {
  (nickname = "", rooms = rooms, selectedRoom = NewRoom,
   newRoomText = "", error = error)
}

typename Model =
  [|  NotConnected : (NotConnectedModel, ClientSelect)
   |  Connected :
        (Nickname,
         ClientSend,
         Maybe((ModeratorSend, Nickname)), # Moderator channel, selected user
         RoomInfo) |];

# Model used to show the HTML page
typename UnrestrictedModel =
  [| UnrNotConnected : NotConnectedModel
   | UnrConnected: (Nickname, Maybe(Nickname), RoomInfo) |];

# This is rather boilerplatey.
# It would be nice to have some way of deriving this automatically,
# or not requiring the function altogether.
sig extract : (Model) ~> (Model, UnrestrictedModel)
fun extract(model) {
  switch(model) {
    case NotConnected(ncModel, cs) ->
        var lin = NotConnected(ncModel, cs);
        var unr = UnrNotConnected(ncModel);
        (lin, unr)
    case Connected(nick, cs, Just(ms, selNick), ri) ->
        var lin = Connected(nick, cs, Just(ms, selNick), ri);
        var unr = UnrConnected(nick, Just(selNick), ri);
        (lin, unr)
    case Connected(nick, cs, Nothing, ri) ->
        var lin = Connected(nick, cs, Nothing, ri);
        var unr = UnrConnected(nick, Nothing, ri);
        (lin, unr)
  }
}

# Messages from the UI
typename UIMessage =
  [|  NoOp
      # Login screen messages
   |  UpdateNickname: Nickname
   |  UpdateSelectedRoom: SelectedRoom
   |  UpdateNewRoom: RoomName
   |  SubmitJoinRoom
      # Chat screen messages
   |  UpdateChatBox: Message
   |  SubmitChat
      # Moderator messages
   |  ModUpdateSelection: Nickname
   |  ModKick
   |  ModMute
   |  ModMakeModerator
      # Incoming session messages from the server
   |  SessionIncomingChat: (Nickname, Message, ClientReceive)
   |  SessionNewUser: (Nickname, ClientReceive)
   |  SessionNewTopic: (Topic, ClientReceive)
   |  SessionUserLeft: (Nickname, ClientReceive)
   |  SessionUserMuted: (Nickname, ClientReceive)
   |  SessionUserUnmuted: (Nickname, ClientReceive)
   |  SessionBecomeModerator: (ModeratorSend, ClientReceive)
   |  SessionKick |];

sig updt : (UIMessage, Model) ~> (Model, Command(UIMessage))
fun updt(msg, model) {

  # Some messages only make sense at certain stages in the application.
  # I wonder whether we could generalise the architecture such that the
  # event loop only needed to consider messages relevant in the current
  # state?

  # Operation on the NotConnected state
  fun withNotConnected(f, model, command) {
    switch(model) {
      case NotConnected(ncModel, cs) ->
        (f(ncModel, cs), command)
      case model -> (model, command)
    }
  }

  # Operation on the Connected state
  fun withConnected(f, model, command) {
    switch(model) {
      case Connected(nick, cs, mi, ri) ->
        (f(nick, cs, mi, ri), command)
      case model -> (model, command)
    }
  }

  fun withMod(f, model, command) {
    switch(model) {
      case Connected(nick, cs, Just(ms, selected), ri) ->
        (f(nick, cs, ms, selected, ri), command)
      case other -> (other, command)
    }
  }

  sig subscribeClient : (ClientReceive) ~> Command(UIMessage)
  fun subscribeClient(cr) {
    sig clientReceive : (ClientReceive) ~> UIMessage
    fun clientReceive(cr) {
      offer(cr) {
        case IncomingChatMessage(cr) ->
          var ((nick, msg), cr) = receive(cr);
          SessionIncomingChat(nick, msg, cr)
        case NewUser(cr) ->
          var (nick, cr) = receive(cr);
          SessionNewUser(nick, cr)
        case NewTopic(cr) ->
          var (topic, cr) = receive(cr);
          SessionNewTopic(topic, cr)
        case UserLeft(cr) ->
          var (nick, cr) = receive(cr);
          SessionUserLeft(nick, cr)
        case UserMuted(cr) ->
          var (nick, cr) = receive(cr);
          SessionUserMuted(nick, cr)
        case UserUnmuted(cr) ->
          var (nick, cr) = receive(cr);
          SessionUserUnmuted(nick, cr)
        case BecomeModerator(cr) ->
          var (ms, cr) = receive(cr);
          SessionBecomeModerator(ms, cr)
        case Kick(_) -> SessionKick
      }
    }
    SpawnLinear(linfun() { clientReceive(cr) })
  }

  fun addChatMessage(nick, msg, ri) {
    (ri with messages = ri.messages ++ [ChatMsg(nick, msg)])
  }

  fun addSystemMessage(msg, ri) {
    (ri with messages = ri.messages ++ [LogMsg(msg)])
  }

  fun userJoined(nick, ri) {
    addSystemMessage(nick ^^ " joined.", ri)
  }

  fun userLeft(nick, ri) {
    var newNicks = filter(fun(x) { x <> nick }, ri.nicknames);
    var ri = addSystemMessage(nick ^^ " left.", ri);
    (ri with nicknames = newNicks)
  }

  fun changeTopic(topic, ri) {
    var ri = addSystemMessage("New topic: " ^^ topic, ri);
    (ri with topic = topic)
  }

  switch(msg) {
    case NoOp -> (model, NoCommand)
    case UpdateNickname(newNick) ->
      withNotConnected(fun(ncModel, cs) {
        NotConnected((ncModel with nickname = newNick), cs)
      }, model, NoCommand)
    case UpdateSelectedRoom(newRoom) ->
      withNotConnected(fun(ncModel, cs) {
        var newModel = (ncModel with selectedRoom = newRoom);
        NotConnected(newModel, cs)
      }, model, NoCommand)
    case UpdateNewRoom(newRoom) ->
      withNotConnected(fun(ncModel, cs) {
        var newModel = (ncModel with newRoomText = newRoom);
        NotConnected(newModel, cs)
      }, model, NoCommand)
    case SubmitJoinRoom ->
      switch(model) {
        case NotConnected(ncModel, (cs: ClientSelect)) ->
          var roomName = switch(ncModel.selectedRoom) {
            case NewRoom -> ncModel.newRoomText
            case SelectedRoom(name) -> name
          };
          var cs = send((ncModel.nickname, roomName), cs);
          offer(cs) {
            case JoinedOK(cs) ->
              # TODO: We could subscribe to this, and have a "Loading" state
              # in between. This is likely better than doing a blocking receive
              # in the event loop! But one step at a time.
              var ((topic, nicks, cr), cs) = receive(cs);
              (Connected(ncModel.nickname, cs, Nothing,
               mkRoomInfo(roomName, topic, nicks)),
               subscribeClient(cr))
            case JoinedOKAsModerator(cs) ->
              var ((topic, nicks, cr, ms), cs) = receive(cs);
              (Connected(ncModel.nickname, cs, Just(ms, ""),
                 mkRoomInfo(roomName, topic, nicks)),
               subscribeClient(cr))
            case Nope(cs) ->
              # Grab error to display
              var (err, _) = receive(cs);
              var displayErr =
                switch(err) {
                  case NameInUse -> ErrNameInUse
                  case BadRoom -> ErrBadRoom
                };
              # Reconnect to get new session and rooms
              var cs = request(wap);
              var (rooms, cs) = receive(cs);
              var newModel = mkNCModel(rooms, Just(displayErr));
              (NotConnected(newModel, cs), NoCommand)
          }
        case other -> (other, NoCommand)
      }
    case UpdateChatBox(newMessage) ->
      withConnected(fun(nick, cs, ms, ri) {
          Connected(nick, cs, ms, (ri with currentChatMessage=newMessage))
      }, model, NoCommand)
    case SubmitChat ->
      withConnected(fun(nick, cs, ms, ri) {
          var cs = select ChatMessage cs;
          var cs = send(ri.currentChatMessage, cs);
          Connected(nick, cs, ms, (ri with currentChatMessage=""))
      }, model, NoCommand)
    case ModUpdateSelection(newSelected) ->
      withMod(fun(nick, cs, ms, _, ri) {
         Connected(nick, cs, Just(ms, newSelected), ri)
      }, model, NoCommand)
    case ModKick ->
      withMod(fun(nick, cs, ms, selected, ri) {
        var ms = select KickUser ms;
        var ms = send(selected, ms);
        var newSelected =
          switch(ri.nicknames) { case [] -> "" case x::xs -> x };
        Connected(nick, cs, Just(ms, newSelected), ri)
      }, model, NoCommand)
    case ModMute ->
      withMod(fun(nick, cs, ms, selected, ri) {
        var ms = select MuteUser ms;
        var ms = send(selected, ms);
        Connected(nick, cs, Just(ms, selected), ri)
      }, model, NoCommand)
    case ModMakeModerator ->
      withMod(fun(nick, cs, ms, selected, ri) {
        var ms = select MakeModerator ms;
        var ms = send(selected, ms);
        Connected(nick, cs, Just(ms, selected), ri)
      }, model, NoCommand)
    case SessionIncomingChat(sender, msg, cr) ->
      withConnected(fun(nick, cs, mi, ri) {
        Connected(nick, cs, mi, addChatMessage(sender, msg, ri))
      }, model, subscribeClient(cr))
    case SessionUserMuted(nick, cr) ->
      withConnected(fun(nick, cs, mi, ri) {
        Connected(nick, cs, mi,
          addSystemMessage(nick ^^ " was muted :(", ri))
      }, model, subscribeClient(cr))
    case SessionUserUnmuted(nick, cr) ->
      withConnected(fun(nick, cs, mi, ri) {
        Connected(nick, cs, mi,
          addSystemMessage(nick ^^ " was unmuted! :)", ri))
      }, model, subscribeClient(cr))
    case SessionNewUser(newUser, cr) ->
      withConnected(fun(nick, cs, mi, ri) {
        Connected(nick, cs, mi, userJoined(newUser, ri))
      }, model, subscribeClient(cr))
    case SessionNewTopic(topic, cr) ->
      withConnected(fun(nick, cs, mi, ri) {
        Connected(nick, cs, mi, changeTopic(topic, ri))
      }, model, subscribeClient(cr))
    case SessionUserLeft(leaver, cr) ->
      withConnected(fun(nick, cs, mi, ri) {
        Connected(nick, cs, mi, userLeft(leaver, ri))
      }, model, subscribeClient(cr))
    case SessionBecomeModerator(ms, cr) ->
      switch(model) {
        case Connected(nick, cs, Nothing, ri) ->
# TODO: "" is a hack, we should have "Select Name" or something,
# or better still, the first nickname
          (Connected(nick, cs, Just(ms, ""), ri),
           subscribeClient(cr))
        case Connected(nick, cs, Just(old, sel), ri) ->
          # We've been given a new moderator channel. This would be
          # odd but we have to account for it. Cancel the old one,
          # and install the new one.
          cancel(old);
          (Connected(nick, cs, Just(ms, sel), ri), subscribeClient(cr))
        case other ->
          # Nothing doing
          cancel(ms);
          (other, subscribeClient(cr))
      }
    case SessionKick ->
      switch(model) {
        # Nothing doing.
        case NotConnected(ncModel, cs) ->
          (NotConnected(ncModel, cs), NoCommand)
        case Connected(_, cs, Just(ms, _), _) ->
          cancel(cs);
          cancel(ms);
          var cs = request(wap);
          var (rooms, cs) = receive(cs);
          (NotConnected(mkNCModel(rooms, Nothing), cs), NoCommand)
        case Connected(nick, cs, Nothing, ri) ->
          cancel(cs);
          var cs = request(wap);
          var (rooms, cs) = receive(cs);
          (NotConnected(mkNCModel(rooms, Nothing), cs), NoCommand)
      }
  }
}

module Render {
  open Tags;
  open Attrs;
  open Events;

#  sig render : (UnrestrictedModel) {}~> Doc(UIMessage)
#  fun render(model) {
#    div([], [], [])
#  }

# rooms, selectedRoom
  sig roomForm : (NotConnectedModel) ~> Doc(UIMessage)
  fun roomForm(ncModel) {
    var newRoomChecked =
      switch(ncModel.selectedRoom) {
        case NewRoom -> true
        case SelectedRoom(_) -> false
      };

    fun enterHandler(keycode) {
      if(keycode == "13") { SubmitJoinRoom } else { NoOp }
    }

    var newRoomRadio : Doc(UIMessage) =
      div([class("radio")], [],
        [
          label([], [], [
            input([type("radio"), name("room"), checked(newRoomChecked)],
              [onInput(fun(_) { UpdateSelectedRoom(NewRoom) })], []),
            textDoc("New Room"),
            input([type("text"), value(ncModel.newRoomText)],
              [onInput(fun(str) { UpdateNewRoom(str) }),
               getKeycode(enterHandler)],
              []
            )
          ])
        ]
      );

    fun roomRadio(roomName) {
      var isChecked =
        switch(ncModel.selectedRoom) {
          case NewRoom -> false
          case SelectedRoom(room) -> roomName == room
        };

      div([class("radio")], [],
        [
          label([], [], [
            input([type("radio"), name("roomName"), checked(isChecked)],
              [onInput(fun(_) { UpdateSelectedRoom(SelectedRoom(roomName))})], []),
            textDoc(roomName)
          ])
        ]
      )
    }

    var radioForm =
      newRoomRadio :: map(fun(roomName) { roomRadio(roomName) }, ncModel.rooms);

    form([], [],
    # TODO: This is why we need a monoidal interface for Doc...
      div([], [], [
        label([for_("nickname")], [], [textDoc("Nickname")]),
        input([type("text"), id("nickname"), autofocus(true)], [], [])
      ]) ::
      (radioForm ++
       [div([], [], [
        input([type("submit"), value("Join")],
          [onClick(fun() { SubmitJoinRoom })], [])])])
    )
  }

  sig render : (UnrestrictedModel) ~> Doc(UIMessage)
  fun render(model) {
    open Tags;

    fun renderMessage(msg) {
      switch(msg) {
        case ChatMsg(nick, msg) ->
          p([], [], [
            b([], [], [textDoc(nick)]),
            textDoc(msg)
          ])
        case LogMsg(msg) ->
          p([], [], [
            b([], [], [textDoc(msg)])
          ])
      }
    }

    switch(model) {
      case UnrNotConnected(ncModel) ->
       # TODO: Render error message
       # TODO: Link nick with nickname form
       div([], [], [
        p([], [], [
          textDoc("Choose one of the existing rooms or create a new one."),
          roomForm(ncModel)])
       ])
      case UnrConnected(nick, modInfo, roomInfo) ->
        var adminBox = div([], [], []); # TODO: Fill me in

        fun infoHeader(description, content) {
          div([], [],
            [p([], [], [span([class("lead")], [], [
              b([], [], [textDoc(description ^^ ": ")]),
              textDoc(content)
            ])])])
        }
        var topic = infoHeader("Topic", roomInfo.topic);
        var room = infoHeader("Room", roomInfo.roomName);
        var msgs = map(renderMessage, roomInfo.messages);
        fun enterHandler(keycode) {
          if(keycode == "13") { SubmitChat } else { NoOp }
        }
        fun inputHandler(str) { UpdateChatBox(str) }

        var chatBox =
          div([Attrs.style("overflow-y:scroll; width:100%; height:400px;"),
               value(roomInfo.currentChatMessage)],
              [getKeycode(enterHandler), onInput(inputHandler)],
              msgs);

        div([], [], [
          adminBox,
          room,
          topic,
          chatBox])
    }
  }
}

fun mainPage() {
  var _ = spawnClient {
    var cs = request(wap);
    var (rooms, cs) = receive(cs);
    var model = NotConnected(mkNCModel(rooms, Nothing), cs);
    runLinearVDom("placeholder", Render.render, updt,
      extract, model, fun(_) { [] })
  };
  page
    <html>
      <head>
        <title>Extended Links Chat Application</title>
        <link href="http://fonts.googleapis.com/css?family=Merriweather:400,300italic,300" rel="stylesheet" type="text/css"></link>
        <link href="http://fonts.googleapis.com/css?family=Kotta+One" rel="stylesheet" type="text/css"></link>
        <link href="http://fonts.googleapis.com/css?family=Lora" rel="stylesheet" type="text/css"></link>
        <link href="css/bootstrap.min.css" rel="stylesheet"></link>
        <link href="css/abcd.css" rel="stylesheet"></link>
      </head>

      <div class="navbar-wrapper">
        <div class="container">
          <div id="navbar" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
          </div>
        </div>
      </div>

      <div class ="jumbotron">
        <div class="container">
          <h1>Links Session-Typed Chat</h1>
          <hr>...complete with totally original stylesheet</hr>
          <div id="placeholder"></div>
        </div>
      </div>


      <div id="main" class="container marketing">
        <div class="row featurette">
          <div id="placeholder"></div>
        </div>
      </div>
    </html>
}
start()
