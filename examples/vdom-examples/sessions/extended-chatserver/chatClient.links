open ChatSessions;
open VirtualDom;

typename ChatMessage = [| Chat: (Nickname, Message), Log: Message |]

# Model: Can be one of three states.
#  1. Not connected to a room
#  2. Connected as "ordinary" user
#  3. Connected as moderator
typename RoomInfo =
  (roomName: RoomName,
   nicknames: [Nickname],
   topic: Topic,
   messages: [ChatMessage],
   currentChatMessage: "");

sig mkRoomInfo : (RoomName, Topic, [Nickname]) -> RoomInfo
fun mkRoomInfo(name, topic, nicks) {
  (roomName=name, nicknames=nicks, topic=topic, messages=[], currentChatMessage=[])
}

typename Error =
  [| ErrInvalidName
   | ErrNameInUse
   | ErrBadRoom
   | ErrKicked
   |];

typename SelectedRoom = [| NewRoom | SelectedRoom: String |];

typename Model =
      # [RoomName]: rooms on server. RoomName: currently-selected room
  [|  NotConnected : (Nickname, [RoomName], SelectedRoom, Maybe(Error), ClientSelect)
   |  Connected :
        (Nickname,
         ClientSend,
         Maybe(ModeratorSend, Nickname), # Moderator channel, selected user
         RoomInfo) |]

# Model used to show the HTML page
typename UnrestrictedModel =
  [| NotConnected : (Nickname, [RoomName], RoomName, Maybe(Error))
   | Connected: (Nickname, Maybe(Nickname), RoomInfo) |]

# This is rather boilerplatey.
# It would be nice to have some way of deriving this automatically,
# or not requiring the function altogether.
sig extract : Model ~> (Model, UnrestrictedModel)
fun extract(model) {
  switch(model) {
    case NotConnected(nick, rooms, selRoom, err, cs) ->
      var lin = NotConnected(nick, rooms, selRoom, err, cs);
      var unr = NotConnected(nick, rooms, selRoom, err);
      (lin, unr)
    case Connected(nick, cs, mi, ri) ->
      switch(mi) {
        case Just(ms, selNick) ->
          var lin = Connected(nick, cs, Just(ms, selNick), ri);
          var unr = Connected(nick, cs, Just(selNick), ri);
          (lin, unr)
        case Nothing ->
          var lin = Connected(nick, cs, mi, ri);
          var unr = Connected(nick, Nothing, ri);
          (lin, unr)
      }
  }
}

# We actually only need one extra function.
# The `extract` function, given a linear model, projects out the unrestricted
# part.
# extract : Model -> (Model, UnrestrictedModel)
# var mod = update(mod, msg);
# var (mod, unrMod) = extract(mod);
# var tree = render(unrMod);
# loop(mod)

# runVDom :
#   (Model, # Initial model
#    Message ~> Model, # Update function
#    Model ~> (LinearModel, UnrestrictedModel),
#    UnrestrictedModel ~> Doc(Message))
#
# updt : Message -> Model
# render : UnrestrictedModel -> UnrestrictedModel

# Messages from the UI
typename Message =
  [|  NoOp
      # Login screen messages
   |  UpdateNickname: Nickname
   |  UpdateSelectedRoom: SelectedRoom
   |  SubmitJoinRoom
      # Chat screen messages
   |  UpdateChatBox: Message
   |  SubmitChat
      # Moderator messages
   |  ModUpdateSelection: Nickname
   |  ModKick
   |  ModMute
   |  ModMakeModerator
      # Incoming session messages from the server
   |  SessionIncomingChat: (Nickname, Message, ClientReceive)
   |  SessionNewUser: (Nickname, ClientReceive)
   |  SessionNewTopic: (Topic, ClientReceive)
   |  SessionUserLeft: (Nickname, ClientReceive)
   |  SessionUserMuted: (Nickname, ClientReceive)
   |  SessionBecomeModerator: (Nickname, ModeratorSend, ClientReceive)
   |  SessionKick |];

sig updt : (Message, Model) ~> Model
fun updt(msg, model) {

  # Some messages only make sense at certain stages in the application.
  # I wonder whether we could generalise the architecture such that the
  # event loop only needed to consider messages relevant in the current
  # state?

  # Operation on the NotConnected state
  fun withNotConnected(f, model) {
    switch(model) {
      case NotConnected(nick, room, err) -> f(nick, room, err)
      case model -> (model, Cmd.None)
    }
  }

  # Operation on the Connected state
  fun withConnected(f, model) {
    switch(model) {
      case Connected(nick, cs, mi, ri) -> f(nick, cs, mi, ri)
      case model -> (model, Cmd.None)
    }
  }

  fun withMod(f, model) {
    switch(model) {
      Connected(nick, cs, Just(ms, selected), ri) ->
        f(nick, cs, ms, selected, ri)
      other -> (other, Cmd.None)
    }
  }

  sig subscribeClient : (ClientReceive) ~> Cmd.Command
  fun subscribeClient(cr) {
    sig clientReceive : (ClientReceive) ~> Message
    fun clientReceive(cr) {
      offer(cr) {
        IncomingChatMessage(cr) ->
          var ((nick, msg), cr) = receive(cr);
          SessionIncomingChat(nick, msg, cr)
        NewUser(cr) ->
          var (nick, cr) = receive(cr);
          SessionNewUser(nick, cr)
        NewTopic(topic, cr) ->
          var (topic, cr) = receive(cr);
          SessionNewTopic(topic, cr)
        UserLeft(cr) ->
          var (nick, cr) = receive(cr);
          SessionUserLeft(topic, cr)
        UserMuted(cr) ->
          var (nick, cr) = receive(cr);
          SessionUserMuted(topic, cr)
        UserUnmuted(cr) ->
          var (nick, cr) = receive(cr);
          SessionUserUnmuted(topic, cr)
        BecomeModerator(cr) ->
          var (ms, cr) = receive(cr);
          SessionBecomeModerator(ms, cr)
        Kick(_) -> SessionKick
      }
    }
    Cmd.Spawn(fun(cr) { clientReceive(cr) })
  }

  switch(msg) {
    case NoOp -> (model, Cmd.None)
    case UpdateNickname(newNick) ->
      withNotConnected(fun(_, roomList, room, err, cs) {
        NotConnected(newNick, roomList, room, err, cs)
      }, model)
    case UpdateJoinRoomBox(newRoom) ->
      withNotConnected(fun(nick, roomList, _, err, cs) {
        NotConnected(nick, roomList, newRoom, err, cs)
      }, model)
    case SubmitJoinRoom ->
      withNotConnected(fun(nick, roomList, room, err, cs) {
        var cs = send((nick, room), cs);
        offer(cs) {
          case JoinedOK(s) ->
            # TODO: We could subscribe to this, and have a "Loading" state
            # in between. This is likely better than doing a blocking receive
            # in the event loop! But one step at a time.
            var ((topic, nicks, cr), s) = receive(s);
            # TODO: Implement `subscribe` functionality to subscribe CR for updates.
            # It might make a little more sense to have this as a "command" a la Elm,
            # because then it'll be processed in the event loop -- which has access
            # to the event loop PID and can direct messages correctly.
            (Connected(nick, cs, Nothing, mkRoomInfo(room, topic, nicks)),
             subscribeClient(cr))
          case JoinedOKAsModerator(s) ->
            var ((topic, nicks, cr, ms), s) = receive(s);
            subscribe(clientReceive(cr));
            (Connected(nick, cs, Just(ms),
               mkRoomInfo(room, topic, nicks)),
             subscribeClient(cr))
          case Nope(s) ->
            # Grab error to display
            var (err, _) = receive(s);
            var displayErr =
              switch(err) {
                case NameInUse -> ErrNameInUse
                case BadRoom -> ErrBadRoom
              };
            # Reconnect to get new session and rooms
            var cs = request(wap);
            var (rooms, cs) = receive(cs);
            (NotConnected("", rooms, "", Just(displayErr), cs), Cmd.None)
        }
      })
    case UpdateChatBox(newMessage) ->
      withConnected(fun(nick, cs, ms, ri) {
          (Connected(nick, cs, ms,
            (ri with currentChatMessage=newMessage)), Cmd.None)
      }, model)
    case SubmitChat ->
      withConnected(fun(nick, cs, ms, ri) {
          var cs = select ChatMessage cs;
          var cs = send(ri.chatMessage, cs);
          (Connected(nick, cs, ms, (ri with chatMessage="")), Cmd.None)
      }, model)
    case ModUpdateSelection(newSelected) ->
      withMod(fun(nick, cs, ms, _, ri) {
        (Connected(nick, cs, Just(ms, newSelected), ri), Cmd.None)
      }, model)
    case ModKick ->
      withMod(fun(nick, cs, ms, selected, ri) {
        var ms = select KickUser ms;
        var ms = send(selected, ms);
        var newSelected =
          switch(ri.nicks) { case [] -> "" case x::xs -> x };
        (Connected(nick, cs, Just(ms, newSelected), ri), Cmd.None)
      }
    case ModMute ->
      withMod(fun(nick, cs, ms, selected, ri) {
        var ms = select MuteUser ms;
        var ms = send(selected, ms);
        Connected(nick, cs, Just(ms, selected), ri)
      }, Cmd.None)
    case ModMakeModerator ->
      withMod(fun(nick, cs, ms, selected, ri) {
        var ms = select MakeModerator ms;
        var ms = send(selected, ms);
        (Connected(nick, cs, Just(ms, selected), ri), Cmd.None)
      }, model)
    case SessionIncomingChat(sender, msg, cr) ->
      withConnected(fun(nick, cs, mi, ri) {
        (Connected(nick, cs, mi, addChatMessage(sender, msg, ri)),
         subscribeClient(cr))
      }, model)
    case SessionNewUser(newUser, cr) ->
      withConnected(fun(nick, cs, mi, ri) {
        (Connected(nick, cs, mi, addUserJoinedMessage(newUser, ri)),
          subscribeClient(cr))
        }, model)
    case SessionNewTopic(topic, cr) ->
      withConnected(fun(nick, cs, mi, ri) {
        (Connected(nick, cs, mi, changeTopic(newTopic, ri)),
          subscribeClient(cr))
      }, model)
    case SessionUserLeft(leaver, cr) ->
      withConnected(fun(nick, cs, mi, ri) {
          #var newNicks = filter(fun(x) { x <> nick }, ri.nicks)
          Connected(nick, cs, mi, userLeft(leaver, ri))
      }, model)
    case SessionBecomeModerator(ms, cr) ->
      switch(model) {
        case Connected(nick, cs, Nothing, ri) ->
          (Connected(nick, cs, Just(ms), ri),
           subscribeClient(cr))
        case Connected(nick, cs, Just(old), ri) ->
          # We've been given a new moderator channel. This would be
          # odd but we have to account for it. Cancel the old one,
          # and install the new one.
          cancel(old);
          (Connected(nick, cs, Just(ms), ri),
           subscribeClient(cr))
        case other ->
          # Nothing doing
          cancel(ms);
          (other, subscribeClient(cr))
      }
    case SessionKick ->
      switch(model) {
        # Nothing doing.
        case NotConnected(nick, rooms, roomsel, err, cs) ->
          (NotConnected(nick, rooms, roomsel, err, cs), Cmd.None)
        case Connected(_, cs, Just(ms, _), _) ->
          cancel(cs);
          cancel(ms);
          var cs = request(wap);
          var (rooms, cs) = receive(cs);
          (NotConnected("", rooms, "", Just(ErrKicked), cs), Cmd.None)
        case Connected(nick, cs, None, ri) ->
          cancel(cs);
          var cs = request(wap);
          var (rooms, cs) = receive(cs);
          (NotConnected("", rooms, "", Just(ErrKicked), cs), Cmd.None)
      }
  }
}

module Render {
  fun roomForm(rooms) {
    var newRoomRadio =
      div([class("radio")], [],
        [
          label([], [], [
            input([type("radio"), name("room"), checked(true)],
              [onInput(fun(_) { UpdateSelectedRoom(NewRoom) })], []),
            textNode("New Room")
          ])
        ]
      );

    fun roomRadio(name) {
      div([class("radio")], [],
        [
          label([], [], [
            input([type("radio"), name("roomName")],
              [onInput(fun(_) { UpdateSelectedRoom(name)})], []),
            textNode(name)
          ])
        ]
      )
    }

    var radioForm =
      newRoomRadio :: map(fun(name) { roomRadio(name) }, rooms);

    form([], [], [
      div([], [], [
        label([for_("nickname")], [], [textDoc("Nickname")]),
        input([type("text"), id("nickname"), autofocus(true)], [], [])
      ]),
      radioForm,
      div([], [], [
        input([type("submit", value("Join"))],
          [onClick(fun() { SubmitJoinRoom })], [])])
    ])
  }

  sig render : (UnrestrictedModel) ~> Doc(Message)
  fun render(model) {
    open Tags;

    switch(model) {
      case NotConnected(nick, rooms, curRoom, err) ->
       # TODO: Render error message
       div([], [], [
        p([], [], [
          textDoc("Choose one of the existing rooms or create a new one.")])
       ])
      case Connected(nick, modInfo, roomInfo) ->
        var adminBox = div([], [], []); # TODO: Fill me in

        fun infoHeader(description, content) {
          div([id("topic"), [],
            [p([span([class("lead")])], [], [
              b([], [], [textDoc(description ^^ ": ")]),
              textDoc(roomInfo.topic)
            ]);
        }
        var topic = infoHeader("Topic", roomInfo.topic);
        var room = infoHeader("Room", roomInfo.roomName);
        var msgs = map(fun(msg) { p([], [], textDoc(msg)) }, roomInfo.messages);
        fun enterHandler(keycode) {
          if(code == "13") { SubmitChat } else { NoOp }
        }
        fun inputHandler(str) { UpdateChatBox(str) }

        var chatBox =
          div([style("overflow-y:scroll; width:100%; height:400px;"),
                text(model.currentChatMessage)],
              [getKeycode(enterHandler), onInput(inputHandler)],
              [msgs]);

        div([], [], [
          { adminBox },
          { room },
          { topic },
          { chatBox }
        ])
    }
  }
}

fun start() {
  spawnClient {
    var cs = request(wap);
    var (rooms, cs) = receive(cs);
    var model = NotConnected("", rooms, "", Just(ErrKicked), cs);
    runLinearVDom("placeholder", Render.render, updt,
      extract, initialModel, [])
  };
  page
    <html>
      <head>
        <title>Extended Links Chat Application</title>
        <link href="http://fonts.googleapis.com/css?family=Merriweather:400,300italic,300" rel="stylesheet" type="text/css"></link>
        <link href="http://fonts.googleapis.com/css?family=Kotta+One" rel="stylesheet" type="text/css"></link>
        <link href="http://fonts.googleapis.com/css?family=Lora" rel="stylesheet" type="text/css"></link>
        <link href="css/bootstrap.min.css" rel="stylesheet"></link>
        <link href="css/abcd.css" rel="stylesheet"></link>
      </head>

      <div class="navbar-wrapper">
        <div class="container">
          <div id="navbar" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
          </div>
        </div>
      </div>

      <div class ="jumbotron">
        <div class="container">
          <h1>Links Session-Typed Chat</h1>
          <hr>...complete with totally original stylesheet</hr>
          <div id="placeholder"></div>
        </div>
      </div>


      <div id="main" class="container marketing">
        <div class="row featurette">
          <div id="placeholder"></div>
        </div>
      </div>
    </html>
}
start()
