open ChatSessions;
open VirtualDom;

typename ChatMessage = [| Chat: (Nickname, Message) | Log: Message |];

# Model: Can be one of three states.
#  1. Not connected to a room
#  2. Connected as "ordinary" user
#  3. Connected as moderator
typename RoomInfo =
  (roomName: RoomName,
   nicknames: [Nickname],
   topic: Topic,
   messages: [ChatMessage],
   currentChatMessage: String);

sig mkRoomInfo : (RoomName, Topic, [Nickname]) -> RoomInfo
fun mkRoomInfo(name, topic, nicks) {
  (roomName=name, nicknames=nicks, topic=topic, messages=[], currentChatMessage="")
}

typename Error =
  [| ErrInvalidName
   | ErrNameInUse
   | ErrBadRoom
   | ErrKicked
   |];

typename SelectedRoom = [| NewRoom | SelectedRoom: String |];

typename Model =
      # [RoomName]: rooms on server. RoomName: currently-selected room
  [|  NotConnected : (Nickname, [RoomName], SelectedRoom, Maybe(Error), ClientSelect)
   |  Connected :
        (Nickname,
         ClientSend,
         Maybe((ModeratorSend, Nickname)), # Moderator channel, selected user
         RoomInfo) |];

# Model used to show the HTML page
typename UnrestrictedModel =
  [| UnrNotConnected : (Nickname, [RoomName], SelectedRoom, Maybe(Error))
   | UnrConnected: (Nickname, Maybe(Nickname), RoomInfo) |];

# This is rather boilerplatey.
# It would be nice to have some way of deriving this automatically,
# or not requiring the function altogether.
sig extract : (Model) ~> (Model, UnrestrictedModel)
fun extract(model) {
  switch(model) {
    case NotConnected(nick, rooms, selRoom, err, cs) ->
      var lin = NotConnected(nick, rooms, selRoom, err, cs);
      var unr = UnrNotConnected(nick, rooms, selRoom, err);
      (lin, unr)
    case Connected(nick, cs, Just(ms, selNick), ri) ->
        var lin = Connected(nick, cs, Just(ms, selNick), ri);
        var unr = UnrConnected(nick, Just(selNick), ri);
        (lin, unr)
    case Connected(nick, cs, Nothing, ri) ->
        var lin = Connected(nick, cs, Nothing, ri);
        var unr = UnrConnected(nick, Nothing, ri);
        (lin, unr)
  }
}

# We actually only need one extra function.
# The `extract` function, given a linear model, projects out the unrestricted
# part.
# extract : Model -> (Model, UnrestrictedModel)
# var mod = update(mod, msg);
# var (mod, unrMod) = extract(mod);
# var tree = render(unrMod);
# loop(mod)

# runVDom :
#   (Model, # Initial model
#    Message ~> Model, # Update function
#    Model ~> (LinearModel, UnrestrictedModel),
#    UnrestrictedModel ~> Doc(Message))
#
# updt : Message -> Model
# render : UnrestrictedModel -> UnrestrictedModel

# Messages from the UI
typename UIMessage =
  [|  NoOp
      # Login screen messages
   |  UpdateNickname: Nickname
   |  UpdateSelectedRoom: SelectedRoom
   |  SubmitJoinRoom
      # Chat screen messages
   |  UpdateChatBox: Message
   |  SubmitChat
      # Moderator messages
   |  ModUpdateSelection: Nickname
   |  ModKick
   |  ModMute
   |  ModMakeModerator
      # Incoming session messages from the server
   |  SessionIncomingChat: (Nickname, Message, ClientReceive)
   |  SessionNewUser: (Nickname, ClientReceive)
   |  SessionNewTopic: (Topic, ClientReceive)
   |  SessionUserLeft: (Nickname, ClientReceive)
   |  SessionUserMuted: (Nickname, ClientReceive)
   |  SessionUserUnmuted: (Nickname, ClientReceive)
   |  SessionBecomeModerator: (ModeratorSend, ClientReceive)
   |  SessionKick |];

sig updt : (UIMessage, Model) ~> Model
fun updt(msg, model) {

  # Some messages only make sense at certain stages in the application.
  # I wonder whether we could generalise the architecture such that the
  # event loop only needed to consider messages relevant in the current
  # state?

  # Operation on the NotConnected state
  fun withNotConnected(f, model) {
    switch(model) {
      case NotConnected(nick, room, err) -> f(nick, room, err)
      case model -> (model, NoCommand)
    }
  }

  # Operation on the Connected state
  fun withConnected(f, model) {
    switch(model) {
      case Connected(nick, cs, mi, ri) -> f(nick, cs, mi, ri)
      case model -> (model, NoCommand)
    }
  }

  fun withMod(f, model) {
    switch(model) {
      case Connected(nick, cs, Just(ms, selected), ri) ->
        f(nick, cs, ms, selected, ri)
      case other -> (other, NoCommand)
    }
  }

  sig subscribeClient : (ClientReceive) ~> Command(UIMessage)
  fun subscribeClient(cr) {
    sig clientReceive : (ClientReceive) ~> UIMessage
    fun clientReceive(cr) {
      offer(cr) {
        case IncomingChatMessage(cr) ->
          var ((nick, msg), cr) = receive(cr);
          SessionIncomingChat(nick, msg, cr)
        case NewUser(cr) ->
          var (nick, cr) = receive(cr);
          SessionNewUser(nick, cr)
        case NewTopic(cr) ->
          var (topic, cr) = receive(cr);
          SessionNewTopic(topic, cr)
        case UserLeft(cr) ->
          var (nick, cr) = receive(cr);
          SessionUserLeft(nick, cr)
        case UserMuted(cr) ->
          var (nick, cr) = receive(cr);
          SessionUserMuted(nick, cr)
        case UserUnmuted(cr) ->
          var (nick, cr) = receive(cr);
          SessionUserUnmuted(nick, cr)
        case BecomeModerator(cr) ->
          var (ms, cr) = receive(cr);
          SessionBecomeModerator(ms, cr)
        case Kick(_) -> SessionKick
      }
    }
    SpawnLinear(linfun() { clientReceive(cr) })
  }

  switch(msg) {
    case NoOp -> (model, NoCommand)
    case UpdateNickname(newNick) ->
      withNotConnected(fun(_, roomList, room, err, cs) {
        NotConnected(newNick, roomList, room, err, cs)
      }, model)
    case UpdateJoinRoomBox(newRoom) ->
      withNotConnected(fun(nick, roomList, _, err, cs) {
        NotConnected(nick, roomList, newRoom, err, cs)
      }, model)
    case SubmitJoinRoom ->
      withNotConnected(fun(nick, roomList, room, err, cs) {
        var cs = send((nick, room), cs);
        offer(cs) {
          case JoinedOK(s) ->
            # TODO: We could subscribe to this, and have a "Loading" state
            # in between. This is likely better than doing a blocking receive
            # in the event loop! But one step at a time.
            var ((topic, nicks, cr), s) = receive(s);
            # TODO: Implement `subscribe` functionality to subscribe CR for updates.
            # It might make a little more sense to have this as a "command" a la Elm,
            # because then it'll be processed in the event loop -- which has access
            # to the event loop PID and can direct messages correctly.
            (Connected(nick, cs, Nothing, mkRoomInfo(room, topic, nicks)),
             subscribeClient(cr))
          case JoinedOKAsModerator(s) ->
            var ((topic, nicks, cr, ms), s) = receive(s);
            subscribe(clientReceive(cr));
            (Connected(nick, cs, Just(ms),
               mkRoomInfo(room, topic, nicks)),
             subscribeClient(cr))
          case Nope(s) ->
            # Grab error to display
            var (err, _) = receive(s);
            var displayErr =
              switch(err) {
                case NameInUse -> ErrNameInUse
                case BadRoom -> ErrBadRoom
              };
            # Reconnect to get new session and rooms
            var cs = request(wap);
            var (rooms, cs) = receive(cs);
            (NotConnected("", rooms, "", Just(displayErr), cs), NoCommand)
        }
      })
    case UpdateChatBox(newMessage) ->
      withConnected(fun(nick, cs, ms, ri) {
          (Connected(nick, cs, ms,
            (ri with currentChatMessage=newMessage)), NoCommand)
      }, model)
    case SubmitChat ->
      withConnected(fun(nick, cs, ms, ri) {
          var cs = select ChatMessage cs;
          var cs = send(ri.chatMessage, cs);
          (Connected(nick, cs, ms, (ri with chatMessage="")), NoCommand)
      }, model)
    case ModUpdateSelection(newSelected) ->
      withMod(fun(nick, cs, ms, _, ri) {
        (Connected(nick, cs, Just(ms, newSelected), ri), NoCommand)
      }, model)
    case ModKick ->
      withMod(fun(nick, cs, ms, selected, ri) {
        var ms = select KickUser ms;
        var ms = send(selected, ms);
        var newSelected =
          switch(ri.nicks) { case [] -> "" case x::xs -> x };
        (Connected(nick, cs, Just(ms, newSelected), ri), NoCommand)
      }, model)
    case ModMute ->
      withMod(fun(nick, cs, ms, selected, ri) {
        var ms = select MuteUser ms;
        var ms = send(selected, ms);
        (Connected(nick, cs, Just(ms, selected), ri), NoCommand)
      }, model)
    case ModMakeModerator ->
      withMod(fun(nick, cs, ms, selected, ri) {
        var ms = select MakeModerator ms;
        var ms = send(selected, ms);
        (Connected(nick, cs, Just(ms, selected), ri), NoCommand)
      }, model)
    case SessionIncomingChat(sender, msg, cr) ->
      withConnected(fun(nick, cs, mi, ri) {
        (Connected(nick, cs, mi, addChatMessage(sender, msg, ri)),
         subscribeClient(cr))
      }, model)
    case SessionUserMuted(nick, cr) ->
      withConnected(fun(nick, cs, mi, ri) {
        (Connected(nick, cs, mi, addSystemMessage(sender, nick ^^ " was muted :(", ri)),
         subscribeClient(cr))
      }, model)
    case SessionUserUnmuted(nick, cr) ->
      withConnected(fun(nick, cs, mi, ri) {
        (Connected(nick, cs, mi, addSystemMessage(sender, nick ^^ " was unmuted! :)", ri)),
         subscribeClient(cr))
      }, model)
    case SessionNewUser(newUser, cr) ->
      withConnected(fun(nick, cs, mi, ri) {
        (Connected(nick, cs, mi, addUserJoinedMessage(newUser, ri)),
          subscribeClient(cr))
        }, model)
    case SessionNewTopic(topic, cr) ->
      withConnected(fun(nick, cs, mi, ri) {
        (Connected(nick, cs, mi, changeTopic(newTopic, ri)),
          subscribeClient(cr))
      }, model)
    case SessionUserLeft(leaver, cr) ->
      withConnected(fun(nick, cs, mi, ri) {
          #var newNicks = filter(fun(x) { x <> nick }, ri.nicks)
          (Connected(nick, cs, mi, userLeft(leaver, ri)), NoCommand)
      }, model)
    case SessionBecomeModerator(ms, cr) ->
      switch(model) {
        case Connected(nick, cs, Nothing, ri) ->
# TODO: "" is a hack, we should have "Select Name" or something,
# or better still, the first nickname
          (Connected(nick, cs, Just(ms, ""), ri),
           subscribeClient(cr))
        case Connected(nick, cs, Just(old, sel), ri) ->
          # We've been given a new moderator channel. This would be
          # odd but we have to account for it. Cancel the old one,
          # and install the new one.
          cancel(old);
          (Connected(nick, cs, Just(ms, sel), ri), subscribeClient(cr))
        case other ->
          # Nothing doing
          cancel(ms);
          (other, subscribeClient(cr))
      }
    case SessionKick ->
      switch(model) {
        # Nothing doing.
        case NotConnected(nick, rooms, roomsel, err, cs) ->
          (NotConnected(nick, rooms, roomsel, err, cs), NoCommand)
        case Connected(_, cs, Just(ms, _), _) ->
          cancel(cs);
          cancel(ms);
          var cs = request(wap);
          var (rooms, cs) = receive(cs);
          (NotConnected("", rooms, NewRoom, Just(ErrKicked), cs), NoCommand)
        case Connected(nick, cs, Nothing, ri) ->
          cancel(cs);
          var cs = request(wap);
          var (rooms, cs) = receive(cs);
          (NotConnected("", rooms, NewRoom, Just(ErrKicked), cs), NoCommand)
      }
  }
}

module Render {
  open Tags;
  open Attrs;
  open Events;

  fun roomForm(rooms, selectedRoom) {
    var newRoomChecked =
      switch(selectedRoom) {
        case NewRoom -> true
        case SelectedRoom(_) -> false
      };

    var newRoomRadio =
      div([class("radio")], [],
        [
          label([], [], [
            input([type("radio"), name("room"), checked(newRoomChecked)],
              [onInput(fun(_) { UpdateSelectedRoom(NewRoom) })], []),
            textDoc("New Room")
          ])
        ]
      );

    fun roomRadio(roomName) {
      var isChecked =
        switch(selectedRoom) {
          case NewRoom -> false
          case SelectedRoom(room) -> roomName == room
        };

      div([class("radio")], [],
        [
          label([], [], [
            input([type("radio"), name("roomName"), checked(isChecked)],
              [onInput(fun(_) { UpdateSelectedRoom(SelectedRoom(roomName))})], []),
            textDoc(roomName)
          ])
        ]
      )
    }

    var radioForm =
      newRoomRadio :: map(fun(roomName) { roomRadio(roomName) }, rooms);

    form([], [],
    # TODO: This is why we need a monoidal interface for Doc...
      div([], [], [
        label([for_("nickname")], [], [textDoc("Nickname")]),
        input([type("text"), id("nickname"), autofocus(true)], [], [])
      ]) ::
      (radioForm ++
       [div([], [], [
        input([type("submit"), value("Join")],
          [onClick(fun() { SubmitJoinRoom })], [])])])
    )
  }

  #sig render : (UnrestrictedModel) ~> Doc(UIMessage)
  fun render(model) {
    open Tags;

    fun renderMessage(msg) {
      switch(msg) {
        case Chat(nick, msg) ->
          p([], [], [
            b([], [], [textDoc(nick)]),
            textDoc(msg)
          ])
        case Log(msg) ->
          p([], [], [
            b([], [], [textDoc(msg)])
          ])
      }
    }

    switch(model) {
      case UnrNotConnected(nick, rooms, curRoom, err) ->
       # TODO: Render error message
       # TODO: Link nick with nickname form
       div([], [], [
        p([], [], [
          textDoc("Choose one of the existing rooms or create a new one."),
          roomForm(rooms, curRoom)])
       ])
      case UnrConnected(nick, modInfo, roomInfo) ->
        var adminBox = div([], [], []); # TODO: Fill me in

        fun infoHeader(description, content) {
          div([], [],
            [p([], [], [span([class("lead")], [], [
              b([], [], [textDoc(description ^^ ": ")]),
              textDoc(content)
            ])])])
        }
        var topic = infoHeader("Topic", roomInfo.topic);
        var room = infoHeader("Room", roomInfo.roomName);
        var msgs = map(renderMessage, roomInfo.messages);
        fun enterHandler(keycode) {
          if(keycode == "13") { SubmitChat } else { NoOp }
        }
        fun inputHandler(str) { UpdateChatBox(str) }

        var chatBox =
          div([Attrs.style("overflow-y:scroll; width:100%; height:400px;"),
               value(roomInfo.currentChatMessage)],
              [getKeycode(enterHandler), onInput(inputHandler)],
              msgs);

        div([], [], [
          adminBox,
          room,
          topic,
          chatBox])
    }
  }
}

fun start() {
  spawnClient {
    var cs = request(wap);
    var (rooms, cs) = receive(cs);
    var model = NotConnected("", rooms, "", Just(ErrKicked), cs);
    runLinearVDom("placeholder", Render.render, updt,
      extract, initialModel, [])
  };
  page
    <html>
      <head>
        <title>Extended Links Chat Application</title>
        <link href="http://fonts.googleapis.com/css?family=Merriweather:400,300italic,300" rel="stylesheet" type="text/css"></link>
        <link href="http://fonts.googleapis.com/css?family=Kotta+One" rel="stylesheet" type="text/css"></link>
        <link href="http://fonts.googleapis.com/css?family=Lora" rel="stylesheet" type="text/css"></link>
        <link href="css/bootstrap.min.css" rel="stylesheet"></link>
        <link href="css/abcd.css" rel="stylesheet"></link>
      </head>

      <div class="navbar-wrapper">
        <div class="container">
          <div id="navbar" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
          </div>
        </div>
      </div>

      <div class ="jumbotron">
        <div class="container">
          <h1>Links Session-Typed Chat</h1>
          <hr>...complete with totally original stylesheet</hr>
          <div id="placeholder"></div>
        </div>
      </div>


      <div id="main" class="container marketing">
        <div class="row featurette">
          <div id="placeholder"></div>
        </div>
      </div>
    </html>
}
start()
