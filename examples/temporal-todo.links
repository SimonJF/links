# Imports
import Mvu;
import MvuHTML;
import MvuAttrs;

# Database Definitions
typename Item = (id: Int, done: Bool, content: String);

var db = database "timedb";

var todoTbl =
  table "todo"        # Table name
    with Item         # Type of items in the table 
    where id readonly # ID is read only -- allows "insert returning"
    using transaction_time(recorded_from, recorded_to)
  from db; # TT Table, specifying fields

# Server functions
fun newItem(content) server {
  var id = tt_insert todoTbl values [(=content, done = false)] returning id;
  (=id, =content, done = false)
}

fun updateItem(id, done, content) server {
  update (x <-t- todoTbl)
    where (x.id == id)
    set (=done, =content)
}

fun deleteItem(id) server {
  delete (x <-t- todoTbl)
    where (x.id == id)
}

### Note: The following two functions work, but they're rather more
### low-level than one might hope. I plan to address this using
### "demotion" views, which allow us to take a temporal table,
### and time-slice it down to a current-time table.
fun getAt(date) {
  query {
    for (x <-t- todoTbl)
      where (ttFrom(x) <= date && date < ttTo(x))
      [ttData(x)]
  }
}

fun getCurrent() {
  query {
    for (x <-t- todoTbl)
      where (ttTo(x) == forever())
      [ttData(x)]
  }
}

# MVU Definitions

typename Model = (items: [Item], newItem: String, timeBox: String);
typename ID = Int;

typename Message =
  [| UpdateBox:String | Submit | ToggleDone:ID | Delete:ID | UpdateTime:String | SubmitTime | SubmitNow |];

fun initialModel(items) {
  (=items, newItem="", timeBox=show(now()))
}

fun updt(msg, model) {
  switch (msg) {
    case UpdateBox(str) -> (model with newItem=str)
    case ToggleDone(id) ->
      var items =
        map(fun(x) {
          if (x.id == id) {
            updateItem(x.id, not(x.done), x.content);
            (x with done = not(x.done))
          } else { x }
        }, model.items);
      (model with =items)
    case Delete(id) ->
      var items = filter(fun(x) { x.id <> id }, model.items);
      deleteItem(id);
      (model with =items)
    case Submit ->
      var item = newItem(model.newItem);
      (model with newItem = "", items = model.items ++ [item])
    case UpdateTime(time) -> (model with timeBox = time)
    case SubmitTime ->
      redirect("/home?at=" ^^ model.timeBox);
      model
    case SubmitNow ->
      redirect("/home");
      model
  }
}

fun view(model) {
  open MvuAttrs;
  open MvuHTML;

  var a0 = MvuAttrs.empty;
  var h0 = MvuHTML.empty;

  fun displayItem(item) {
    var checkedAttr = checked(item.done);
    var text =
      if (item.done) {
        s(a0, textNode(item.content))
      } else {
        textNode(item.content)
      };

    var deleteButton =
      button(onClick(fun() { Delete(item.id) }), textNode("Delete"));

    input(type("checkbox") +@
        checkedAttr +@
        onChange(fun(_) { ToggleDone(item.id) }), h0) +*
    label(a0, text) +*
    deleteButton +*
    br(a0, h0)
  }

  var renderedItems = MvuHTML.concatMap(displayItem, model.items);

  var newItemBox =
    div(a0,
      input(type("text") +@ onInput(fun(str) { UpdateBox(str) }) +@ value(model.newItem), h0) +*
      button(onClick(fun() { Submit }), textNode("New item")));

  var timeTravelBox =
    div(a0,
      h1(a0, textNode("Time-travel")) +*
      input(type("text") +@ onInput(fun(str) { UpdateTime(str) }) +@ value(model.timeBox), h0) +*
      button(onClick(fun() { SubmitTime }), textNode("Time-travel!")) +*
      button(onClick(fun() { SubmitNow }), textNode("Present day!"))
    );

  h1(a0, textNode("To-do")) +*
  renderedItems +*
  newItemBox +*
  timeTravelBox
}

fun mainPage() {
  var model =
    switch (lookup("at", environment())) {
      case Just(date) -> initialModel(getAt(parseDate(date)))
      case _ -> initialModel(getCurrent())
    };
  Mvu.runSimple("placeholder", model, view, updt);
  page
    <html>
      <div id="placeholder"></div>
    </html>
}

serveThis(mainPage)
